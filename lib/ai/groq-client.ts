import { rateLimiter } from './rate-limiter'
import { getAvailableModels, AIModelConfig } from './config'

interface GroqResponse {
  choices: Array<{
    message: {
      content: string
    }
  }>
}

export class GroqClient {
  private apiKey: string
  private baseUrl = 'https://api.groq.com/openai/v1'

  constructor(apiKey: string) {
    this.apiKey = apiKey
  }

  async generateContent(prompt: string, modelName?: string, maxRetries = 3): Promise<string> {
    const availableModels = getAvailableModels().filter(m => m.type === 'groq')
    if (availableModels.length === 0) {
      throw new Error('No Groq models available')
    }

    // Use specified model or first available Groq model
    const model = modelName 
      ? availableModels.find(m => m.name === modelName) || availableModels[0]
      : availableModels[0]

    if (!model) {
      throw new Error('No Groq models available')
    }

    // Extract actual model name (remove groq/ prefix if present)
    const actualModelName = model.name.startsWith('groq/') ? model.name.substring(5) : model.name

    // Check rate limit
    const hasQuota = await rateLimiter.checkQuota(model.name, model.rateLimit)
    if (!hasQuota) {
      const waitTime = await rateLimiter.waitForQuota(model.name, model.rateLimit)
      throw new Error(`Rate limit exceeded. Wait ${Math.ceil(waitTime / 1000)} seconds.`)
    }

    let lastError: Error | null = null

    for (let attempt = 0; attempt < maxRetries; attempt++) {
      try {
        const response = await fetch(`${this.baseUrl}/chat/completions`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${this.apiKey}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            model: actualModelName,
            messages: [
              {
                role: 'user',
                content: prompt
              }
            ],
            max_tokens: model.maxTokens,
            temperature: 0.7,
            top_p: 0.9
          })
        })

        if (!response.ok) {
          const errorText = await response.text()
          throw new Error(`Groq API error: ${response.status} - ${errorText}`)
        }

        const data: GroqResponse = await response.json()
        
        if (!data.choices || data.choices.length === 0) {
          throw new Error('No content generated by Groq')
        }

        const choice = data.choices[0]
        if (!choice || !choice.message || !choice.message.content) {
          throw new Error('Invalid response structure from Groq')
        }

        const generatedText = choice.message.content
        
        // Consume quota on successful request
        await rateLimiter.consumeQuota(model.name, model.rateLimit)
        
        return generatedText

      } catch (error) {
        lastError = error instanceof Error ? error : new Error('Unknown error')
        
        if (attempt < maxRetries - 1) {
          // Wait before retry (exponential backoff)
          await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000))
        }
      }
    }

    throw lastError || new Error('Failed to generate content after retries')
  }

  async isAvailable(): Promise<boolean> {
    try {
      const availableModels = getAvailableModels().filter(m => m.type === 'groq')
      if (availableModels.length === 0) return false

      const model = availableModels[0]
      if (!model) return false
      
      const hasQuota = await rateLimiter.checkQuota(model.name, model.rateLimit)
      return hasQuota && !!this.apiKey
    } catch {
      return false
    }
  }

  getUsage() {
    const availableModels = getAvailableModels().filter(m => m.type === 'groq')
    if (availableModels.length === 0) return { minute: 0, day: 0 }
    
    const model = availableModels[0]
    if (!model) return { minute: 0, day: 0 }
    
    return rateLimiter.getUsage(model.name)
  }
}

export const groqClient = new GroqClient(process.env.GROQ_API_KEY || '')
